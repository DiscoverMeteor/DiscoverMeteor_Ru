---
title: Создание постов
slug: creating-posts
date: 0007/01/01
number: 7
contents: Узнаете как создать новый пост на клиенте.|Создадите простую проверку данных.|Ограничите доступ к форме создания поста.|Научитесь использовать методы проверки данных на сервере для лучшей безопасности.
paragraphs: 60
---

Мы уже знаем как создавать новые посты через консоль командой `Posts.insert`. Но было бы жестоко заставлять наших пользователей открывать консоль и печатать команды обращения к базе данных.

Нам нужно создать дружелюбный пользовательский интерфейс для новых постов.

### Создаем страницу новых постов

Для начала создадим путь к нашей новой странице:

~~~js
Router.configure({
  layoutTemplate: 'layout',
  loadingTemplate: 'loading',
  waitOn: function() { return Meteor.subscribe('posts'); }
});

Router.map(function() {
  this.route('postsList', {path: '/'});

  this.route('postPage', {
    path: '/posts/:_id',
    data: function() { return Posts.findOne(this.params._id); }
  });

  this.route('postSubmit', {
    path: '/submit'
  });
});

Router.onBeforeAction('loading');
~~~
<%= caption "lib/router.js" %>
<%= highlight "14~17" %>

### Добавляем линк в заголовок

Теперь, когда у нас есть адрес (route) новой страницы, давайте добавим на нее ссылку в заголовок:

~~~html
<template name="header">
  <header class="navbar">
    <div class="navbar-inner">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>
      <a class="brand" href="{{pathFor 'postsList'}}">Microscope</a>
      <div class="nav-collapse collapse">
        <ul class="nav">
          <li><a href="{{pathFor 'postSubmit'}}">New</a></li>
        </ul>
        <ul class="nav pull-right">
          <li>{{loginButtons}}</li>
        </ul>
      </div>
    </div>
  </header>
</template>
~~~
<%= caption "client/views/includes/header.html" %>
<%= highlight "11~13" %>

Создание адреса означает, что если пользователь решит открыть адрес `/submit` в браузере, Meteor отрендерит шаблон `postSubmit`. Давайте создадим этот шаблон:

~~~html
<template name="postSubmit">
  <form class="main">
    <div class="control-group">
        <label class="control-label" for="url">URL</label>
        <div class="controls">
            <input name="url" type="text" value="" placeholder="Your URL"/>
        </div>
    </div>

    <div class="control-group">
        <label class="control-label" for="title">Title</label>
        <div class="controls">
            <input name="title" type="text" value="" placeholder="Name your post"/>
        </div>
    </div>

    <div class="control-group">
        <label class="control-label" for="message">Message</label>
        <div class="controls">
            <textarea name="message" type="text" value=""></textarea>
        </div>
    </div>

    <div class="control-group">
        <div class="controls">
            <input type="submit" value="Submit" class="btn btn-primary"/>
        </div>
    </div>
  </form>
</template>

~~~
<%= caption "client/views/posts/post_submit.html" %>

Внимание - куча новой разметки. Но вся она родом из Twitter Bootstrap. Да, нам нужна только форма нового поста. Но дополнительные теги и классы сделают все гораздо симпатичнее. Теперь наша новая страница будет выглядеть примерно так:

<%= screenshot "7-1", "Форма для нового поста" %>

Нам не нужно волноваться насчет параметра `action` для этой формы, так как мы перехватим событие и отправим данные с помощью JavaScript. Также не стоит волноваться насчет варианта когда JavaScript отключен в браузере - ведь тогда приложение Meteor просто не будет работать.

### Создание постов

Давайте создадим обработчик событий для кнопки `Submit`. Проще всего использовать событие `submit` (чем, например, ловить событие `click` на кнопке), ведь тогда мы охватим все возможные сценарии событий, включая нажатие кнопки `Enter` в поле с URL.

~~~js
Template.postSubmit.events({
  'submit form': function(e) {
    e.preventDefault();

    var post = {
      url: $(e.target).find('[name=url]').val(),
      title: $(e.target).find('[name=title]').val(),
      message: $(e.target).find('[name=message]').val()
    }

    post._id = Posts.insert(post);
    Router.go('postPage', post);
  }
});
~~~
<%= caption "client/views/posts/post_submit.js" %>

<%= commit "7-1", "Добавлена страница с новым постом, и линк на нее в заголовке страницы" %>

Эта функция использует [jQuery](http://jquery.com) чтобы собрать данные со всех полей формы и создать объект нового поста. Мы также добавили вызов `preventDefault` для события `event`, чтобы браузер не попытался отправить форму традиционным способом.

Наконец, мы можем перенаправить пользователя на страницу с новым постом. Вызов функции `insert()` у коллекции вернет свежий `id` объекта, который только что был добавлен в базу данных. Этот параметр мы добавим в вызов `Router.go()` - он будет добавлен в адресную строку.

Теперь пользователь может отправить новый пост кнопкой `Submit` - пост будет создан, и пользователен перенаправлен на страницу с постом и комментариями.

### Добавим немного безопасности

Все это замечательно, но было бы неплохо ограничить доступ к созданию новых постов только для зарегистрированных пользователей. Мы могли бы спрятать форму на странице, но не смотря на это любой разбирающийся в браузерах человек мог бы открыть консоль и создать пост оттуда.

К счастью, защита данных зашита прямо в коллекции Meteor. Просто она по-умолчанию отключена для новых проектов. Это позволяет легко начать новое приложение не тратя время на скучные вещи.

Нашему приложению больше не нужны эти костыли, поэтому настало время от них избавиться. Давайте удалим пакет `insecure`:

~~~bash
$ meteor remove insecure
~~~
<%= caption "Терминал" %>

Возможно вы заметили что форма с новыми постами перестала работать. Это потому, что без пакета `insecure` редактирование коллекций на клиенте запрещено. Нам нужно специально сообщить Meteor'у что клиентам можно создавать новые посты. Или создавать посты прямо на сервере.

### Разрешаем создание новых постов

Для начала мы быстро починим отправку формы, разрешив создание постов на клиенте. Вы увидите позже что мы остановимся на немного другом подходе, но сейчас мы можем все починить следующим образом:

~~~js
Posts = new Meteor.Collection('posts');

Posts.allow({
  insert: function(userId, doc) {
    // разрешить постить только если пользователь залогинен
    return !! userId;
  }
});
~~~
<%= caption "collections/posts.js" %>
<%= highlight "3~8" %>

<%= commit "7-2", "Удалили пакет insecure, разрешили определенные записи в посты" %>

Вызов `Posts.allow` сообщает Meteor'у что "в этих обстоятельствах клиентам разрешено модифицировать коллекцию `Posts`". В данном случае мы говорим что "клиентам можно создавать новые посты до тех пор пока в них есть `userId`".

Параметр `userId` пользователя, который создает пост, будет передан вызовам `allow` и `deny` (или функция вернет `null` если пользователь не залогинен), что очень полезно. Так как пользовательские аккаунты привязаны к ядру Meteor, мы можем рассчитывать на то что `userId` всегда верен.

Мы ограничили создание постов только для авторизированных пользователей. Попробуйте выйти из аккаунта и создать пост - вы скорее всего увидите следующее в консоли:

<%= screenshot "7-2", "Insert failed: Access denied " %>

Отлично. Осталась еще пара вещей.

 - Неавторизованным пользователям все еще доступна форма создания новых постов
 - Пост никак не привязан к пользователю (и у нас нет кода на сервере для этого)
 - Можно создать множество постов с одним и тем же URL.

Давайте это исправим.

### Ограничиваем доступ к форме с новыми постами

Если пользователь не залогинен, ему не стоит показывать форму для новых постов. Верным местом для такого ограничения будет роутер. Для этого мы создадим *router hook*.

*Hook* умеет вмешиваться в процесс роутера - когда мы перенаправляем пользователей согласно адресу на определенные функции нашего приложения. Hook похож на охранника проверяющего документы прежде чем пропустить дальше (или не пропустить).

Нам нужно проверить залогинен ли пользователь. Если нет - отрендерить шаблон `accessDenied` вместо привычного `postSubmit`, а также остановить роутер и не дать ему больше ничего сделать. Давайте перепишем наш router.js:

~~~js
Router.configure({
  layoutTemplate: 'layout',
  loadingTemplate: 'loading',
  waitOn: function() { return Meteor.subscribe('posts'); }
});

Router.map(function() {
  this.route('postsList', {path: '/'});
  
  this.route('postPage', {
    path: '/posts/:_id',
    data: function() { return Posts.findOne(this.params._id); }
  });
  
  this.route('postSubmit', {
    path: '/submit'
  });
});


var requireLogin = function(pause) {
  if (! Meteor.user()) {
    this.render('accessDenied');
    pause();
  }
}

Router.onBeforeAction('loading');
Router.onBeforeAction(requireLogin, {only: 'postSubmit'});
~~~
<%= caption "lib/router.js" %>
<%= highlight "19~26,29" %>

Теперь создадим шаблон для страницы "Доступ запрещен":

~~~html
<template name="accessDenied">
  <div class="alert alert-error">You can't get here! Please log in.</div>
</template>
~~~
<%= caption "client/views/includes/access_denied.html" %>

<%= commit "7-3", "Доступ запрещен к странице с новыми постами если юзер не залогинен" %>

Если вы попробуете открыть адрес http://localhost:3000/submit/ и при этом не будете залогинены, вы увидите нашу новую страницу:

<%= screenshot "7-3", "Шаблон - доступ запрещен" %>

Забавная штука насчет условий перенаправления (*routing hooks*) в том что они _реактивны_. Это означает что нам не нужно думать о проверке статуса пользователя когда страница уже отрендерена. Если статус логина пользователя изменится в лучшую сторону, роутер тут же отрендерит новую страницу - `postSubmit` вместо `accessDenied`. Для этого нам не нужно писать дополнительного кода, все просто работает.

Авторизируйтесь и попробуйте обновить страницу. Иногда вы успеете заметить страницу "Доступ запрещен" на краткое мгновение перед тем, как появится форма нового поста. Это все потому, что Meteor начинает рендерить шаблоны как можно раньше, еще до того, как приложение успело побеседовать с сервером и спросить насчет существования текущего пользователя (который пока что сохранен в local storage браузера).

Чтобы избежать этой проблемы - а это распространенная проблема, с которой вы еще столкнетесь когда будете разбирать пикантные детали задержек передачи данных между клиентом и сервером - просто покажем экран загрузки на тот краткий момент, пока мы выясняем, если ли у текущего пользователя право создавать новые посты.

В данный момент мы еще не знаем, напечатал ли пользователь корректно свой логин и пароль. И мы не можем показать шаблон `accessDenied` или `postSubmit` до тех пор, пока это не выяснится.

Перепишем наш hook чтобы использовать шаблон загрузки страницы до тех пор пока `Meteor.loggingIn()` возвращает true:

~~~js
Router.map(function() {
  this.route('postsList', {path: '/'});
  
  this.route('postPage', {
    path: '/posts/:_id',
    data: function() { return Posts.findOne(this.params._id); }
  });
  
  this.route('postSubmit', {
    path: '/submit'
  });
});


var requireLogin = function(pause) {
  if (! Meteor.user()) {
    if (Meteor.loggingIn())
      this.render(this.loadingTemplate);
    else
      this.render('accessDenied');
    
    pause();
  }
}

Router.onBeforeAction('loading');
Router.onBeforeAction(requireLogin, {only: 'postSubmit'});
~~~
<%= caption "lib/router.js" %>
<%= highlight "16~19" %>

<%= commit "7-4", "Показываем экран загрузки пока проверяется логин" %>

### Прячем линк

Самы простой способ предотвратить пользователей от доступа к странице по ошибке это просто спрятать линк когда они не залогинены. Легко:

~~~html
<ul class="nav">
  {{#if currentUser}}<li><a href="{{pathFor 'postSubmit'}}">Submit Post</a></li>{{/if}}
</ul>
~~~
<%= caption "client/views/includes/header.html" %>

<%= commit "7-5", "Показывать ссылку на создание поста только когда пользователь залогинен" %>

Хелпер `currentUser` доступен для нас через пакет `accounts` и является в шаблонах handlebars тем же самым, что и вызов `Meteor.user()`. Так как он реактивен, линк будет появляться и исчезать на странице когда статус логин пользователя будет меняться.

###Метод Meteor: абстракция и безопасность на новом уровне

Мы закрыли доступ к странице с новыми постами для неавторизированных пользователей, а также запретили создание новых постов через консоль браузера. Осталось еще несколько моментов:

- Дата и время создания для каждого поста
- Добавить проверку уникальности URL в каждом посте. Один и тот же URL нельзя запостить дважды.
- Добавить детали автора поста (ID, имя пользователя, и все такое)

Первая мысль вероятно будет что мы можем все это воплотить в нашем обработчике события `submit`. На практике это вызвало бы массу проблем:

- Для даты и времени поста нам пришлось бы рассчитывать на дату-время компьютера пользователя, которая вполне может оказаться неверной.
- Браузер не сможет знать про _все_ посты когда-либо отправленные на сайт. Только текущие посты будут сохранены в локальной базе данных браузера (чуть позже мы разберем как это работает). Так что мы никак не сможем проверить уникальность поля URL в новом посте.
- Наконец, даже если мы и _могли бы_ добавить детали автора на клиенте, мы никак не смогли бы проверить их верность, что открыло бы дыру в безопасности для людей, использующих консоль браузера.

Из-за всех этих причин нам стоит держать обработчики событий простыми. Если мы собираемся совершать более продвинутые операции с добавлением и редактированием коллекций, стоит использовать **Метод**.

Метод Meteor - это функция на сервере, которую можно вызвать из клиента. Пока что мы плохо с ними знакомы - хотя на самом деле, за кулисами, методы `insert`, `update`, `remove` наших коллекций все являются Методами. Давайте узнаем, как создать наш собственный Метод.

Вернемся к файлу `post_submit.js`. Вместо того чтобы добавлять новый пост напрямую в коллекцию `Posts`, мы вызовем Метод под названием `post`:

~~~js
Template.postSubmit.events({
  'submit form': function(e) {
    e.preventDefault();

    var post = {
      url: $(e.target).find('[name=url]').val(),
      title: $(e.target).find('[name=title]').val(),
      message: $(e.target).find('[name=message]').val()
    }

    Meteor.call('post', post, function(error, id) {
      if (error)
        return alert(error.reason);

      Router.go('postPage', {_id: id});
    });
  }
});
~~~
<%= caption "client/views/posts/post_submit.js" %>

Функция `Meteor.call` вызовет Метод по имени первого аргумента. Вы можете добавить аргументов к этому вызову (в данном случае объект `post`, созданный из формы), и еще добавить функцию, которая будет вызвана когда Метод на сервере закончит обработку. В нашем случае мы покажем ошибку, если что-то пошло не так; и перенаправим пользователя на страницу с новым постом если все хорошо.

Теперь объявим Метод в файле `collections/posts.js`. Мы уберем блок `allow()` из `posts.js`, так как Методы Meteor игнорируют их в любом случае. Обратите внимание что Методы выполняются на сервере, и Meteor предполагает что им можно доверять.

~~~js
Posts = new Meteor.Collection('posts');

Meteor.methods({
  post: function(postAttributes) {
    var user = Meteor.user(),
      postWithSameLink = Posts.findOne({url: postAttributes.url});

    // Удостоверимся что пользователь залогинен
    if (!user)
      throw new Meteor.Error(401, "You need to login to post new stories");

    // Проверим что у поста есть заголовок
    if (!postAttributes.title)
      throw new Meteor.Error(422, 'Please fill in a headline');

    // Проверим что нет других постов с таким же линком
    if (postAttributes.url && postWithSameLink) {
      throw new Meteor.Error(302,
        'This link has already been posted',
        postWithSameLink._id);
    }

    // Выберем поля разрешенные для публикации
    var post = _.extend(_.pick(postAttributes, 'url', 'title', 'message'), {
      userId: user._id,
      author: user.username,
      submitted: new Date().getTime()
    });

    var postId = Posts.insert(post);

    return postId;
  }
});
~~~
<%= caption "collections/posts.js" %>

<%= commit "7-6", "Используем Метод для создания нового поста" %>

Код Метода может показаться несколько сложным, но мы верим что вы сможете в нем разобраться.

Для начала создаем переменную `user` и проверяем нет ли другого поста с таким же линком. Затем проверяем, авторизирован ли пользователь на сайте. Если нет - выдаем диалог с ошибкой. Также мы проверяем объекты новых постов на наличие заголовков.

Дальше - если есть пост с таким же линком, мы выдаем ошибку `302` (означает перенаправление на другую страницу), тем самым намекая пользователю что они могут взглянуть на уже существующую страницу с предудыщим постом.

Класс `Error` Meteor'a требует три аргумента. Первый (`error`) будет кодом `302`. Второй (`reason`) это краткое описание ошибки на понятном людям языке. Последний аргумент (`details`) может быть любой дополнительной информацией.

В нашем случае мы используем третий аргумент для передачи ID поста-дубликата, который мы обнаружили. Внимание - спойлеры: мы используем эту информацию позже чтобы перенаправить пользователя на страницу с этим постом.

Если новый пост проходит все проверки, мы отбираем нужные поля для отправки на сервер используя метод [pick из библиотеки Underscore](http://underscorejs.org/#pick). Это нужно для того, чтобы пользователь не смог добавить дополнительных полей через консоль браузера. Затем мы добавляем в пост информацию о пользователе отправителе, а также текущее время используя метод [extend](http://underscorejs.org/#extend).

Наконец, мы добавляем пост в базу данных и возвращаем `id` нового поста пользователю.

### Сортируем посты

Теперь когда у каждого поста есть время-дата, мы можем упорядочить все посты по этому атрибуту. Для этого воспользуемся оператором Mongo `sort`. Как аргумент мы передадим объект состоящий из название поля, по которому мы хотим упорядочить объекты, а также направление - возрастающее или убывающее.

~~~js
Template.postsList.helpers({
  posts: function() {
    return Posts.find({}, {sort: {submitted: -1}});
  }
});
~~~
<%= caption "client/views/posts/posts_list.js" %>
<%= highlight "3" %>

<%= commit "7-7", "Сортируем объекты по времени создания" %>

Всё это заняло у нас некоторое время - но теперь у нас есть полноценный интерфейс для создания контента!

Вдобавок к созданию контента пользователи захотят редактировать уже существующие посты, а также удалять их. Об этом и будет следующая глава.
