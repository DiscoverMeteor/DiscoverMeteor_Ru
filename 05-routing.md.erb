---
title: Маршрутизация (Routing)
slug: routing
date: 0005/01/01
number: 5
points: 10
photoUrl: http://www.flickr.com/photos/ikewinski/9517814403/
photoAuthor: Mike Lewinski
contents: Изучите маршрутизацию в Meteor.|Создадите страницы обсуждения постов с уникальными URL-ми.|Изучите как делать ссылки с такими URL-ми правильно.
---

Теперь, когда мы имеем список постов (которые в конце концов отправят пользователи), нам нужна отдельная страница для каждого поста, где наши пользователи смогут обсудить его.

Мы бы хотели, чтобы эти страницы были доступны через *постоянную ссылку* (*permalink*) -- URL вида `http://myapp.com/posts/xyz` (где `xyz` -- идентификатор `_id` в MongoDB), которая уникальна для каждого поста.

Для этого нам понадобится какая-нибудь *маршрутизация (routing)*, чтобы адресная строка в браузере правильно соответствовала отображаемому контенту.

### Добавление пакета Iron Router

[Iron Router](https://github.com/EventedMind/iron-router) -- это пакет маршрутизации, который был задуман специально для Meteor приложений.

Он помогает не только в маршрутизации (настройке путей), но он может также позаботиться о фильтрации (сопоставление действий к некоторым путям), и даже управлять подписками (контролировать, какой путь имеет доступ к этим данным). (Примечание: Iron Router частично был разработан Tom Coleman -- соавтором книги *Discover Meteor*.)

Во-первых, установим пакет из Atmosphere:

~~~bash
$ mrt add iron-router
~~~
<%= caption "Terminal" %>

Эта команда скачает и установит пакет iron-router для использования вашим приложением. Заметьте, что вам иногда будет нужно перезапустить Meteor приложение (с помощью `ctrl+c` убить процесс, затем `mrt` чтобы запустить его снова) перед тем как пакет может быть использован.

Обратите внимание, что Iron Router это сторонний пакет, поэтому вам понадобится Meteorite для его установки (`meteor add iron-router` не будет работать).

<% note do %>

### Термины Маршрутизации

В этой главе мы коснёмся большинства различных особенностей маршрутизации. Если вы имеете некоторый опыт с фреймворками такими как Rails, вам будут уже знакомы большинство из этих концепций. Но если это не так, здесь приводится краткий словарик для быстрого ознакомления:

- **Маршруты (Routes)**: Основной строительный блок маршрутизации. Это в основном набор инструкций, которые говорят куда идти и что делать при встрече с данным URL-ом.
- **Пути (Paths)**: URL внутри вашего приложения. Он может быть статичным (`/terms_of_service`) или динамичным (`/posts/xyz`), и даже включать параметры запроса (`/search?keyword=meteor`).
- **Сегменты (Segments)**: Различные части пути, разделенные прямым слэшем (`/`).
- **Обработчики (Hooks)**: Действия, которые вы захотите произвести перед, после, или даже во время процесса маршрутизации. Типичным примером может быть проверка прав пользователя перед отображением страницы.
- **Фильтры (Filters)**: Простые обработчики, которые вы глобально определяете для одного или нескольких маршрутов.
- **Шаблоны маршрутов (Route Templates)**: Каждому маршруту нужно указать шаблон. Если вы его не укажете маршрутизатор будет искать шаблон с таким же именем как у маршрута по умолчанию.
- **Макеты (Layouts)**: Вы можете думать о макетах, как о цифровых фоторамках. Они содержат в себе весь html-код, который оборачивается текущим шаблоном, и будут оставаться ими же, даже если шаблон изменится.
- **Контроллеры (Controllers)**: Иногда, вы будете понимать, что многие ваши шаблоны переиспользуют одни и те же параметры. Взамен дублирования кода, вы можете все эти маршруты наследовать от одного *маршрутного контроллера (routing controller)*, который будет содержать всю логику маршрутизации.

Для более подробной информации об Iron Router смотрите [полную документацию на GitHub](https://github.com/EventedMind/iron-router).

<% end %>

### Маршрутизация: Сопоставление URL-ов С Шаблонами

До сих пор мы делали сборку нашего макета используя жёстко заданные вставки шаблонов (такие как `{{>postsList}}`). Таким образом контент нашего приложения может меняться, но основная структура страницы всегда одинакова: заголовок со списком постов ниже.

Iron Router позволяет нам убежать от этой замшелости взятием на себя отрисовки внутри html-тега `<body>`. Поэтому мы не будем определять содержимое этого тега сами, как мы делали этого с обычной html-страницей. Взамен, мы укажем маршрут к специальному макету, который содержит метод шаблона `{{yield}}`.

Этот `{{yield}}` метод определит специальную динамическую зону, которая автоматически будет отрисовывать шаблон соответствующий текущему маршруту (договоримся, с этого места такие специальные шаблоны мы будем называть «маршрутными шаблонами» (“route templates”)):

<%= diagram "router-diagram", "Layouts and templates.", "pull-center" %>

Мы начнем с создания нашего макета и добавлением метода `{{yield}}`. Вначале мы удалим наш html-тег `<body>` из `main.html` и переместим его контент в свой шаблон `layout.html`.

Итак наш похудевший `main.html` теперь выглядит так:

~~~html
<head>
  <title>Microscope</title>
</head>
~~~
<%= caption "client/main.html" %>

В то время новосозданный `layout.html` теперь будет содержать внешний макет приложения:

~~~html
<template name="layout">
  <div class="container">
  <header class="navbar">
    <div class="navbar-inner">
      <a class="brand" href="/">Microscope</a>
    </div>
  </header>
  <div id="main" class="row-fluid">
    {{yield}}
  </div>
  </div>
</template>
~~~
<%= caption "client/views/application/layout.html" %>

Как вы можете заметить, мы заменили включение шаблона `postsList` вызовом метода `yield`. Вы заметите, что после этого изменения мы ничего не увидим на экране. Это потому, что мы еще не сказали маршрутизатору что делать с URL-ом `/`, поэтому он просто выдаёт пустой шаблон.

Для начала мы можем вернуть наше старое поведение сделав соответствие корневого URL-а `/` к шаблону `postsList`. Мы создадим каталог `/lib` в корне нашего проекта, а внутри создадим `router.js`:

~~~js
Router.configure({
  layoutTemplate: 'layout'
});

Router.map(function() {
  this.route('postsList', {path: '/'});
});
~~~
<%= caption "lib/router.js"%>

Мы сделали две важные вещи. Во-первых, мы сказали маршрутизатору использовать макет, который мы просто создали как макет по-умолчанию для всех маршутов. Во-вторых, мы определили новый маршрут называемый `postsList` и отображенный на путь `/`.

<% note do %>

### Папка `/lib`

Что угодно положенное в папку `/lib` гарантированно загрузится первым, прежде чем всё остальное в вашем приложении (за возможным исключением умных пакетов). Это делает папку `/lib` отличным место для любого вспомогательного кода, который нужен доступным всё время.

Небольшое предупреждение: заметим что поскольку папки `/lib` нет внутри папок `/client` или `/server` это означает что её контент будет доступен для обоих окружений.

<% end %>

### Именованные Маршруты

Проясним здесь некоторые моменты. Мы назвали наш маршрут `postsList`, но мы также назвали *шаблон* -- `postsList`. И что же здесь происходит?

По умолчанию Iron Router ищет шаблон с таким же именем как и маршрут. По факту он будет даже искать *путь (path)* основанный на имени маршрута, это означает, что мы не определив свой путь (который мы указываем опцией `path` в нашем описании маршрута), сделали наш шаблон по умолчанию доступным по URL `/postsList`.

Вам может быть интересно, почему нам вообще нужно давать имя нашим маршрутам. Именованные маршруты позволят нам использовать несколько особенностей Iron Router чтобы облегчить создание ссылок внутри приложения. Один из самых полезных методов в Handlebars -- это `{{pathFor}}`, который возвращает компонент URL путь любого маршрута.

Мы хотим, чтобы наша ссылка на главную страницу указывала на список постов. Вместо того чтобы определить статический URL `/` мы можем также использовать метод в Handlebars. Конечный результат будет такой же, но это даст нам больше гибкости так как этот метод будет всегда выводить правильный URL даже если мы изменим путь маршрута в маршрутизаторе.

~~~html
<header class="navbar">
  <div class="navbar-inner">
    <a class="brand" href="{{pathFor 'postsList'}}">Microscope</a>
  </div>
</header>

//...
~~~
<%= caption "client/views/application/layout.html"%>
<%= highlight "3" %>

<%= commit "5-1", "Very basic routing." %>

### В Ожидании Данных

Если вы проведете развертывание текущей версии приложения (или запустите экземпляр используя ссылку выше), вы заметите что перед списком постов некоторое время отображается пустой список. Это потому что вначале загрузки страницы нет постов для отображения до тех пор пока подписчик `posts` не закончит забирать данные с сервера.

Было бы намного лучше для взаимодействия с пользователем обеспечить визуальную обратную связь чего-то происходящего.

К счастью, Iron Router даёт нам простой способ сделать это -- мы воспользуемся подписчиком `waitOn`:

~~~js
Router.configure({
  layoutTemplate: 'layout',
  loadingTemplate: 'loading',
  waitOn: function() { return Meteor.subscribe('posts'); }
});

Router.map(function() {
  this.route('postsList', {path: '/'});
});
~~~
<%= caption "lib/router.js" %>
<%= highlight "3,4" %>

Разберемся с этим кодом. Во-первых, мы изменили блок `Router.configure()` обеспечив маршрутизатор именем загрузочного шаблона (который мы скоро создадим) для перенаправления на него пока наше приложение ожидает данные.

Во-вторых, мы также добавили функцию `waitOn`, которая возвращает нашу `posts` подписку. Это означает, что маршрутизатор будет гарантировать то, что подписка `posts` подгрузится перед отправкой пользователя по маршуруту, который он запросил.

Заметим, что поскольку мы определяем нашу функцию `waitOn` глобально на уровне маршрутизации, она сработает когда пользователь впервые зайдёт в ваше приложение. После этого данные уже будут загружены в память браузера и маршрутизатору не нужно будет ждать их снова.

А так как мы сейчас позволили маршрутизатору обрабатывать нашу подписку, вы теперь можете безопасно удалить её из `main.js` (который теперь будет пустым).

Это как правило хорошая идея ожидать ваши подписки, не просто только для взаимодействия с пользователем, но и также потому что это означает что вы можете с уверенностью предположить что данные всегда будут доступны в шаблоне. Это устраняет необходимость иметь дело с шаблонами начинающими отрисовку перед тем, как их базовые данные будут доступны.

Финальным кусочком головоломки будет сам шаблон процесса загрузки. Для создания прекрасного анимированного индикатора загрузки мы воспользуемся пакетом `spin`. Добавим его с `mrt add spin`, и потом создадим шаблон `loading`:

~~~html
<template name="loading">
  {{>spinner}}
</template>
~~~
<%= caption "client/views/includes/loading.html" %>

Заметьте что `{{>spinner}}` частично содержится в `spin` пакете. Даже если эта часть приходит “извне” нашего приложения, мы можем вставлять его также как и любой другой шаблон.

<%= commit "5-2", "Wait on the post subscription." %>

<% note do %>

### Первый Взгляд На Реактивность

Реактивность это базовая часть Meteor, и хотя мы еще по настоящему не касались её, наш шаблон загрузки даёт первый взгляд на эту концепцию.

Перенаправление на шаблон загрузки, пока данные загружаются, это конечно же хорошо. Но как маршрутизатор узнал, что нужно перенаправить пользователя *обратно* на правильную страницу как только данные были получены?

На данный момент, скажем просто, что это однозначно работает реактивность. Но не беспокойтесь, вы скоро изучите её.

<% end %>

### Маршрутизация К Указанному Посту

Теперь, когда мы увидели как указывать маршрут к шаблону `postsList`, давайте построим маршрут для отображения подробного вида одного поста.

Есть только одна загвоздка: мы не можем определить свой отдельный маршрут для каждого поста -- ведь их будет огромное множество. Вместо этого нам стоит создать один *динамический* маршрут, и заставить его показывать любой пост.

Для начала мы создадим новый шаблон, который просто отрисовывает такой же шаблон поста, что мы использовали ранее в списке постов.

~~~html
<template name="postPage">
  {{> postItem}}
</template>
~~~
<%= caption "client/views/posts/post_page.html" %>

Мы добавим больше элементов (таких как комментарии) к этому шаблону позже, но на данный момент он будет служить простой оболочкой для нашей вставки `{{> postItem}}`.

Теперь создадим другой именованный маршрут, на этот раз отображение путей URL-а формы `/posts/<ID>` к шаблону `postPage`:

~~~js
Router.map(function() {
  this.route('postsList', {path: '/'});
  
  this.route('postPage', {
    path: '/posts/:_id'
  });
});

~~~
<%= caption "lib/router.js" %>
<%= highlight "4~6" %>

Специальный синтаксис `:_id` сообщает маршрутизатору две вещи: первое, совпадает любой маршрут формы `/posts/xyz/`, где “xyz” может принимать любое значение. Второе, положить всё что найдено на месте “xyz” во внутрь свойства `_id` массива `params` маршрутизатора.

Обратите внимание: мы используем `_id` здесь только ради удобства. Маршрутизатор не имеет возможности узнать, отправляем ли мы актуальный `_id` или просто некоторую случайную строку символов.

Теперь мы имеем маршрут к правильному шаблону, но нам чего-то нехватает: маршрутизатор знает `_id` поста, который мы бы хотели показать, но шаблон не имеет о нём никакого представления.

К счастью, маршрутизатор имеет неплохое встроенное решение: он позволяет указать **контекст данных (data context)** для шаблона. Вы можете думать о данных контекста как о начинке в торте, который сделан из шаблонов и макетов. Проще говоря это то чем вы заполняете шаблон:

<%= diagram "router-diagram-2", "The data context.", "pull-center" %>

В нашем случае мы получим правильный контекст данных, отыскав наш пост по `_id`, который мы получили из URL-а:

~~~js
Router.map(function() {
  this.route('postsList', {path: '/'});
  
  this.route('postPage', {
    path: '/posts/:_id',
    data: function() { return Posts.findOne(this.params._id); }
  });
});

~~~
<%= caption "lib/router.js" %>
<%= highlight "4~7" %>

Итак, каждый раз когда пользователь обращается по этому маршруту мы находим соответствующий пост и отправляем его в шаблон. Напомним, что `findOne` возвращает единственный пост совпавший с запросом, и ему можно передать только один аргумент `id` для сокращения записи `{_id: id}`.

Внутри функции `data` для маршрута, `this` соответствует текущему совпавшему маршруту, и мы можем использовать `this.params` для доступа к именованым частям маршрута (которые мы обозначили с помощью префиксов `:` внутри нашего `path`).

<% note do %>

### Подробнее О Контекстах С Данными

Передавая контекст данных шаблону, вы можете контролировать значение `this` внутри методов шаблона.

Это обычно делается неявно в итераторе `{{#each}}`, который автоматически устанавливает контекст данных каждой итерации к текущему элементу итерации:

~~~html
{{#each widgets}}
  {{> widgetItem}}
{{/each}}
~~~

Но мы можем также сделать это явно используя `{{#with}}`, который просто говорит: "возьми этот объект, и примени следующий шаблон к нему". Например, мы можем написать:

~~~html
{{#with myWidget}}
  {{> widgetPage}}
{{/with}}
~~~

Оказывается вы можете добиться того же результата отправкой контекста как *аргумента* в месте вызова шаблона. Таким образом предыдущий блок кода может быть переписан так:

~~~js
{{> widgetPage myWidget}}
~~~

<% end %>

### Использование Методов Шаблона Для Динамических Поименованных Маршрутов

Наконец мы должны убедиться, что указываем ли мы на правильное место, которое мы хотим связать с индивидуальным постом. Снова мы могли бы сделать как-то так `<a href="/posts/{{_id}}">`, но мы используем метод шаблона для маршрутизации -- он просто более надёжен.

Мы поименовали маршрут к посту как `postPage`, таким образом мы можем использовать метод шаблона `{{pathFor 'postPage'}}`:

~~~html
<template name="postItem">
  <div class="post">
    <div class="post-content">
      <h3><a href="{{url}}">{{title}}</a><span>{{domain}}</span></h3>
    </div>
    <a href="{{pathFor 'postPage'}}" class="discuss btn">Discuss</a>
  </div>
</template>
~~~
<%= caption "client/views/posts/post_item.html"%>
<%= highlight "6" %>
<%= commit "5-3", "Routing to a single post page." %>

Но подождите, как именно маршрутизатор знает где взять часть `xyz` в `/posts/xyz`? В конце концов мы не передаем ему любой `_id`.

Оказывается, Iron Router достаточно умён чтобы понять это самому. Мы говорим маршрутизатору использовать маршурут `postPage`, и маршрутизатор узнаёт, что этот маршрут требует некий параметр `_id` (ведь он прописан нами в определении маршрута `path`).

Таким образом маршрутизатор поищет этот `_id` в наиболее логичных доступных местах: контекст данных метода `{{pathFor 'postPage'}}`, другими словами `this`. А бывает так, что наш `this` соответствует посту, который (сюрприз!) действительно обладает свойством `_id`.

В качестве альтернативы вы также можете явно говорить маршрутизатору где бы вы хотели найти свойство `_id`, отправив второй аргумент методу шаблона (т.е. `{{pathFor 'postPage' someOtherPost}}`). Практически использовать этот паттерн можно, например, для получения предыдущих или следующих постов в списке.

Чтобы убедиться, что всё работает правильно, в браузере проследуйте к списку постов и кликните по какой-нибудь ссылке 'Discuss'. Вы должны увидеть что-то подобное этому:

<%= screenshot "5-2", "A single post page." %>

<% note do %>

### HTML5 pushState

Стоит понимать, что изменения адреса URL происходят с помощью технологии [HTML5 pushState](https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Manipulating_the_browser_history?redirectlocale=en-US&redirectslug=Web%2FGuide%2FDOM%2FManipulating_the_browser_history).

Маршрутизатор умеет отлавливать клики на локальных линках, одновременно не давая браузеру покинуть приложение. Вместо этого маршрутизатор просто вносит изменения в состояние приложения.

Если все работает корректно, страница должна измениться мгновенно. По факту, иногда всё меняется так быстро, что может понадобиться какая-нибудь страница перехода. Это выходит за рамки этой главы, но тем не менее эта тема интересна.

<% end %>